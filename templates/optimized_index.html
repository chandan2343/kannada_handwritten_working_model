<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>‡≤ï‡≤®‡≥ç‡≤®‡≤° Handwritten Characters Recognition</title>
    <style>
        :root {
            --bg: #5a319dff;
            --card: rgba(34, 74, 105, 0.08);
            --card-dark: rgba(12, 16, 32, 0.92);
            --text: #e8ecff;
            --muted: #a7b2d9;
            --accent: #7c3aed;
            --accent-2: #00c6ff;
            --stroke: #0d162d;
            --shadow: 0 18px 50px rgba(0,0,0,0.35);
            --radius: 18px;
        }
        * { margin:0; padding:0; box-sizing:border-box; }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background:
                radial-gradient(circle at 20% 20%, rgba(124,58,237,0.18), transparent 32%),
                radial-gradient(circle at 80% 0%, rgba(0,198,255,0.16), transparent 28%),
                linear-gradient(145deg, rgba(6,9,24,0.95) 0%, rgba(8,12,28,0.9) 60%, rgba(6,9,24,0.96) 100%),
                url("{{ url_for('static', filename='background.jpg') }}") center/cover fixed;
            color: var(--text);
            min-height: 100vh;
            background-attachment: fixed;
        }
        body.dark-mode {
            filter: brightness(0.96);
            background:
                radial-gradient(circle at 20% 20%, rgba(124,58,237,0.22), transparent 32%),
                radial-gradient(circle at 80% 0%, rgba(0,198,255,0.20), transparent 28%),
                linear-gradient(145deg, rgba(4,6,14,0.97) 0%, rgba(7,10,20,0.94) 60%, rgba(4,6,14,0.98) 100%),
                url("{{ url_for('static', filename='background.jpg') }}") center/cover fixed;
        }
        body::after {
            content:"";
            position: fixed;
            inset:0;
            pointer-events: none;
            background: radial-gradient(circle at 15% 80%, rgba(255,255,255,0.05), transparent 32%),
                        radial-gradient(circle at 90% 50%, rgba(255,255,255,0.04), transparent 28%);
            mix-blend-mode: screen;
        }
        .container { max-width: 1280px; margin: 0 auto; padding: 20px; position: relative; z-index:1; }
        header {
            display:flex; justify-content:space-between; align-items:center;
            background: rgba(255,255,255,0.06);
            padding: 16px 20px;
            border-radius: var(--radius);
            border:1px solid rgba(255,255,255,0.12);
            box-shadow: var(--shadow);
            margin-bottom: 18px;
            backdrop-filter: blur(10px);
        }
        h1 { font-size: clamp(24px, 3vw, 32px); color:#f5f7ff; letter-spacing:0.4px; }
        .theme-toggle {
            border:none; cursor:pointer; border-radius:12px; padding:10px 14px;
            background: linear-gradient(135deg, var(--accent), var(--accent-2));
            color:#0a0f1f; font-weight:700; box-shadow: 0 12px 30px rgba(0,198,255,0.3);
        }
        main { display:grid; grid-template-columns: 1.1fr 0.9fr; gap:18px; }
        @media(max-width: 900px){ main { grid-template-columns:1fr; } }
        .card {
            background: rgba(255,255,255,0.08);
            border:1px solid rgba(255,255,255,0.12);
            border-radius: var(--radius);
            box-shadow: var(--shadow);
            padding: 18px;
            backdrop-filter: blur(12px);
        }
        .card h2 { margin-bottom:10px; font-size:20px; color:#f0f4ff; }
        .muted { color: var(--muted); font-size: 0.95rem; margin-bottom:12px; }
        .canvas-wrap {
            background: rgba(255,255,255,0.05);
            border-radius: var(--radius);
            border:1px dashed rgba(255,255,255,0.16);
            padding:12px;
            display:none;
            justify-content:center;
            align-items:center;
            min-height: 360px;
        }
        .canvas-wrap.active {
            display:flex;
        }
        canvas {
            width: 100%;
            max-width: 640px;
            height: 320px;
            background:#fff;
            border-radius: 16px;
            box-shadow: 0 16px 40px rgba(0,0,0,0.4);
            touch-action: none;
        }
        .image-display {
            background: rgba(255,255,255,0.05);
            border-radius: var(--radius);
            border:1px dashed rgba(255,255,255,0.16);
            padding:12px;
            display:none;
            justify-content:center;
            align-items:center;
            min-height: 360px;
        }
        .image-display.active {
            display:flex;
        }
        .image-display {
            position: relative;
        }
        .image-display img {
            width: 100%;
            max-width: 640px;
            height: 320px;
            object-fit: contain;
            background:#fff;
            border-radius: 16px;
            box-shadow: 0 16px 40px rgba(0,0,0,0.4);
        }
        .image-navigation {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 12px;
            gap: 12px;
        }
        .nav-btn {
            padding: 8px 16px;
            border-radius: 8px;
            border: 1px solid rgba(255,255,255,0.18);
            background: rgba(255,255,255,0.12);
            color: #e8ecff;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.2s;
            flex: 0 0 auto;
        }
        .nav-btn:hover:not(:disabled) {
            background: rgba(255,255,255,0.18);
            transform: translateY(-1px);
        }
        .nav-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .nav-btn:active {
            transform: translateY(0);
        }
        .image-counter {
            color: var(--muted);
            font-size: 0.95rem;
            font-weight: 500;
            flex: 1;
            text-align: center;
        }
        .tool-controls {
            display:flex;
            gap:10px;
            margin-top:12px;
            align-items:center;
        }
        .tool-btn {
            padding:8px 16px;
            border-radius:8px;
            border:1px solid rgba(255,255,255,0.18);
            background: rgba(255,255,255,0.12);
            color:#e8ecff;
            cursor:pointer;
            font-weight:500;
            transition: all 0.2s;
            display:flex;
            align-items:center;
            gap:6px;
        }
        .tool-btn.active {
            background: linear-gradient(135deg, var(--accent), var(--accent-2));
            color:#0a0f1f;
            border-color: transparent;
            box-shadow: 0 4px 12px rgba(124,58,237,0.3);
        }
        .tool-btn:hover {
            background: rgba(255,255,255,0.18);
            transform: translateY(-1px);
        }
        .tool-btn.active:hover {
            background: linear-gradient(135deg, var(--accent), var(--accent-2));
            box-shadow: 0 6px 16px rgba(124,58,237,0.4);
        }
        .tool-btn:active {
            transform: translateY(0);
        }
        .controls { display:flex; flex-wrap:wrap; gap:10px; margin-top:12px; }
        .btn {
            border:none; cursor:pointer; border-radius:12px; padding:10px 14px;
            font-weight:600; color:#0a0f1f;
            background: linear-gradient(135deg, var(--accent), var(--accent-2));
            box-shadow: 0 12px 28px rgba(124,58,237,0.3);
        }
        .btn.secondary { background: rgba(255,255,255,0.12); color:#e8ecff; border:1px solid rgba(255,255,255,0.18); box-shadow:none; }
        .inline {
            display:flex; flex-wrap:wrap; gap:10px; align-items:center; margin-top:12px;
        }
        label { color:#cfd6f2; font-size:0.95rem; }
        .mode-toggle { display:flex; gap:12px; align-items:center; flex-wrap:wrap; margin-top:8px; }
        .pill {
            padding:8px 12px; border-radius:10px; cursor:pointer;
            background: rgba(255,255,255,0.06); border:1px solid rgba(255,255,255,0.16); color:#e8ecff;
            position: relative;
        }
        .pill input { margin-right:6px; }
        .pill.disabled {
            opacity: 0.5;
            cursor: not-allowed;
            pointer-events: none;
        }
        .pill[title]:hover::after {
            content: attr(title);
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            padding: 6px 10px;
            background: rgba(0,0,0,0.9);
            color: #fff;
            border-radius: 6px;
            font-size: 0.85rem;
            white-space: nowrap;
            z-index: 1000;
            margin-bottom: 5px;
            pointer-events: none;
        }
        .pill[title]:hover::before {
            content: '';
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            border: 5px solid transparent;
            border-top-color: rgba(0,0,0,0.9);
            z-index: 1000;
            margin-bottom: -5px;
        }
        .uploaders { display:flex; flex-wrap:wrap; gap:10px; margin-top:10px; }
        .file-input { display:none; }
        .output-text {
            font-size: clamp(20px, 4vw, 34px);
            font-weight: 700;
            color:#f5f7ff;
            min-height: 64px;
            padding:12px 0;
            word-break: break-word;
        }
        .output-label { color:#cfd6f2; font-size: 0.95rem; letter-spacing:0.3px; }
        .output-actions { display:flex; gap:10px; flex-wrap:wrap; margin-top:12px; }
        .status { margin-top:10px; color: var(--muted); font-size:0.9rem; }
        .hidden { display:none; }
        .loading { display:none; text-align:center; margin-top:10px; color:#cfd6f2; }
        .spinner {
            width:28px; height:28px; border-radius:50%;
            border:3px solid rgba(255,255,255,0.2);
            border-top-color: var(--accent-2);
            animation: spin 0.9s linear infinite;
            margin:0 auto 8px;
        }
        @keyframes spin { to { transform: rotate(360deg); } }
    </style>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+Kannada:wght@400;700&display=swap" rel="stylesheet">
</head>
<body>
    <div class="container">
        <header>
            <h1>‡≤ï‡≤®‡≥ç‡≤®‡≤° Handwritten Characters Recognition</h1>
            <button class="theme-toggle" onclick="toggleDarkMode()">üåô / ‚òÄ</button>
        </header>

        <main>
            <section class="card">
                <h2>Draw or Upload</h2>
                <p class="muted">Write single characters, compound ottaksharas, or full words. Use the canvas or upload images.</p>
                <div class="uploaders">
                    <button class="btn secondary" onclick="openCanvas()">‚úè Open Canvas</button>
                    <button class="btn secondary" onclick="document.getElementById('singleInput').click()">üì∑ Single Image</button>
                    <button class="btn secondary" onclick="document.getElementById('multipleInput').click()">üñº Multiple Images</button>
                    <input type="file" id="singleInput" class="file-input" accept="image/*">
                    <input type="file" id="multipleInput" class="file-input" accept="image/*" multiple>
                </div>
                <div class="canvas-wrap" id="canvasWrap">
                    <canvas id="drawingCanvas" width="512" height="320"></canvas>
                </div>
                <div class="image-display" id="imageDisplay">
                    <img id="uploadedImage" src="" alt="Uploaded image">
                    <div class="image-navigation" id="imageNavigation" style="display:none;">
                        <button class="nav-btn" id="prevBtn" onclick="navigateImage('prev')">‚óÄ Previous</button>
                        <span class="image-counter" id="imageCounter">1 / 1</span>
                        <button class="nav-btn" id="nextBtn" onclick="navigateImage('next')">Next ‚ñ∂</button>
                    </div>
                </div>
                <div class="tool-controls" id="canvasControls" style="display:none;">
                    <button class="tool-btn active" id="penBtn" onclick="setTool('pen')">‚úè Pen</button>
                    <button class="tool-btn" id="eraserBtn" onclick="setTool('eraser')">üßπ Eraser</button>
                </div>
                <div class="controls" id="actionControls" style="display:none;">
                    <button class="btn secondary" onclick="clearCanvas()">Clear</button>
                    <button class="btn" onclick="recognizeAction()">Recognize</button>
                </div>
                <div class="mode-toggle">
                    <label class="pill" id="modeWord"><input type="radio" name="mode" value="word" checked> Word / Single</label>
                    <label class="pill" id="modeSequence" title="Canvas supports single character only. Use upload for sequences."><input type="radio" name="mode" value="sequence" id="radioSequence"> Character sequence</label>
                    <label class="pill" id="modeSentence" title="Canvas supports single character only. Use upload for sequences."><input type="radio" name="mode" value="sentence" id="radioSentence"> Sentence (with spaces)</label>
                </div>
                <div id="loading" class="loading">
                    <div class="spinner"></div>
                    <div>Processing‚Ä¶</div>
                </div>
                <div id="error" class="status hidden" style="color:#ff7b7b;"></div>
            </section>

            <section class="card">
                <h2>Recognized Output</h2>
                <p class="output-label">Recognized Text</p>
                <div class="output-text" id="predictedText">‚Äî</div>
                <div class="output-actions">
                    <button class="btn" id="ttsBtn" onclick="speakText()" disabled>üîä Hear Output</button>
                    <button class="btn secondary" onclick="downloadText()">üìÑ Save Text</button>
                    <button class="btn secondary" onclick="downloadPDF()">üìë Save PDF</button>
                </div>
                <div class="status" id="sessionStatus">Canvas mode ‚Ä¢ Word</div>
            </section>
        </main>
    </div>

    <script>
        const canvas = document.getElementById('drawingCanvas');
        const ctx = canvas.getContext('2d');
        let drawing = false;
        let points = [];
        let currentSession = null;
        let currentMode = 'word';
        let currentSource = null;
        let recognizedText = '';
        let isDark = false;
        let currentTool = 'pen'; // 'pen' or 'eraser'
        let totalImages = 1; // Track total number of uploaded images
        let currentImageIndex = 0; // Track current image index
        let currentConfidence = null; // Last prediction confidence (0-1)
        let currentUncertaintyMessage = ''; // Optional uncertainty hint

        const dpr = window.devicePixelRatio || 1;
        function setupCanvas() {
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;
            ctx.scale(dpr, dpr);
            resetCanvas();
        }
        function resetCanvas() {
            // Clear the entire canvas
            ctx.fillStyle = isDark ? '#0f172a' : '#fff';
            ctx.fillRect(0, 0, canvas.width / dpr, canvas.height / dpr);
            // Reapply tool settings after clearing
            setTool(currentTool);
        }
        window.addEventListener('resize', setupCanvas);

        function setTool(tool) {
            currentTool = tool;
            if (tool === 'pen') {
                // Pen settings: draw black strokes
                ctx.globalCompositeOperation = 'source-over';
                ctx.strokeStyle = '#000';
                ctx.fillStyle = '#000';
                ctx.lineWidth = 6;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                ctx.globalAlpha = 1.0;
                // Update button states
                const penBtn = document.getElementById('penBtn');
                const eraserBtn = document.getElementById('eraserBtn');
                if (penBtn) penBtn.classList.add('active');
                if (eraserBtn) eraserBtn.classList.remove('active');
            } else if (tool === 'eraser') {
                // Eraser settings: remove pixels
                ctx.globalCompositeOperation = 'destination-out';
                ctx.lineWidth = 20; // Larger eraser for better usability
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                ctx.globalAlpha = 1.0; // Full opacity for complete erasing
                // Update button states
                const penBtn = document.getElementById('penBtn');
                const eraserBtn = document.getElementById('eraserBtn');
                if (penBtn) penBtn.classList.remove('active');
                if (eraserBtn) eraserBtn.classList.add('active');
            }
        }

        function openCanvas() {
            // Hide image display if shown
            document.getElementById('imageDisplay').classList.remove('active');
            // Show canvas
            document.getElementById('canvasWrap').classList.add('active');
            document.getElementById('canvasControls').style.display = 'flex';
            document.getElementById('actionControls').style.display = 'flex';
            currentSource = 'canvas';
            // Force Word/Single mode for canvas and disable sequence/sentence options
            updateModeToggleState();
            updateSessionStatus();
            // Ensure canvas is properly set up
            setupCanvas();
            // Initialize with pen tool
            setTool('pen');
        }

        function startDraw(x, y) {
            if (!canvas.getBoundingClientRect().width) return; // Canvas not ready
            drawing = true;
            points = [{x,y}];
            
            // Ensure tool settings are applied at start
            setTool(currentTool);
            
            // Draw initial point (important for single clicks)
            ctx.beginPath();
            ctx.arc(x, y, currentTool === 'eraser' ? 10 : 3, 0, Math.PI * 2);
            if (currentTool === 'pen') {
                ctx.fill();
            } else {
                ctx.fill(); // destination-out will erase
            }
        }
        
        function drawLine(x, y) {
            if (!drawing) return;
            
            // Ensure tool settings are maintained during drawing
            if (currentTool === 'pen') {
                ctx.globalCompositeOperation = 'source-over';
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 6;
            } else {
                ctx.globalCompositeOperation = 'destination-out';
                ctx.lineWidth = 20;
            }
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            
            const prev = points[points.length - 1];
            points.push({x,y});
            
            // Smooth drawing with quadratic curves
            ctx.beginPath();
            ctx.moveTo(prev.x, prev.y);
            
            if (points.length > 1) {
                // Use quadratic curve for smoother lines
                const midX = (prev.x + x) / 2;
                const midY = (prev.y + y) / 2;
                ctx.quadraticCurveTo(prev.x, prev.y, midX, midY);
            } else {
                ctx.lineTo(x, y);
            }
            
            ctx.stroke();
        }
        
        function endDraw() { 
            drawing = false; 
            points = []; 
            // Reapply tool settings after drawing ends
            setTool(currentTool);
        }

        // Enhanced pointer event handlers with proper coordinate handling
        function getCanvasCoordinates(e) {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            return {
                x: (e.clientX - rect.left) * scaleX / dpr,
                y: (e.clientY - rect.top) * scaleY / dpr
            };
        }

        canvas.addEventListener('pointerdown', (e) => {
            e.preventDefault();
            const coords = getCanvasCoordinates(e);
            startDraw(coords.x, coords.y);
            canvas.setPointerCapture(e.pointerId);
        });
        
        canvas.addEventListener('pointermove', (e) => {
            e.preventDefault();
            if (drawing) {
                const coords = getCanvasCoordinates(e);
                drawLine(coords.x, coords.y);
            }
        });
        
        canvas.addEventListener('pointerup', (e) => {
            e.preventDefault();
            endDraw();
            canvas.releasePointerCapture(e.pointerId);
        });
        
        canvas.addEventListener('pointerleave', (e) => {
            e.preventDefault();
            endDraw();
        });
        
        // Prevent context menu on right-click
        canvas.addEventListener('contextmenu', (e) => {
            e.preventDefault();
        });

        function updateModeToggleState() {
            // All modes are now enabled for both Canvas and Upload
            // Canvas will use segmentation for sequence/sentence modes
            const sequenceLabel = document.getElementById('modeSequence');
            const sentenceLabel = document.getElementById('modeSentence');
            const sequenceRadio = document.getElementById('radioSequence');
            const sentenceRadio = document.getElementById('radioSentence');
            
            // Remove disabled state - all modes work now
            sequenceLabel.classList.remove('disabled');
            sentenceLabel.classList.remove('disabled');
            sequenceRadio.disabled = false;
            sentenceRadio.disabled = false;
            
            // Remove tooltips since modes are now enabled
            sequenceLabel.removeAttribute('title');
            sentenceLabel.removeAttribute('title');
        }
        
        document.querySelectorAll('input[name="mode"]').forEach(r=>{
            r.addEventListener('change', () => {
                // Allow all modes for Canvas - segmentation will handle it
                currentMode = r.value;
                updateSessionStatus();
            });
        });

        function clearCanvas() {
            resetCanvas();
            recognizedText = '';
            updatePredictedText('‚Äî');
            hideError();
            // Keep tool selection
            setTool(currentTool);
            // Reset confidence state
            currentConfidence = null;
            currentUncertaintyMessage = '';
            updateSessionStatus();
        }

        function updatePredictedText(text) {
            recognizedText = text || '';
            document.getElementById('predictedText').textContent = recognizedText || '‚Äî';
            document.getElementById('ttsBtn').disabled = !recognizedText;
        }

        function showLoading() { document.getElementById('loading').style.display = 'block'; }
        function hideLoading() { document.getElementById('loading').style.display = 'none'; }
        function showError(msg) {
            const el = document.getElementById('error');
            el.textContent = msg;
            el.classList.remove('hidden');
        }
        function hideError() { document.getElementById('error').classList.add('hidden'); }

        function updateSessionStatus() {
            let sourceText = 'Ready';
            if (currentSource === 'canvas') {
                sourceText = 'Canvas';
            } else if (currentSource === 'upload') {
                if (totalImages > 1) {
                    sourceText = `Upload (${totalImages} images)`;
                } else {
                    sourceText = 'Upload';
                }
            }
            const modeText = currentMode === 'sequence'
                ? 'Character sequence'
                : currentMode === 'sentence'
                    ? 'Sentence'
                    : 'Word/Single';
            let status = `${sourceText} ‚Ä¢ ${modeText}`;

            if (typeof currentConfidence === 'number') {
                const pct = (currentConfidence * 100).toFixed(1);
                status += ` ‚Ä¢ ${pct}% confidence`;
            }
            if (currentUncertaintyMessage) {
                status += ` ‚Ä¢ ${currentUncertaintyMessage}`;
            }

            document.getElementById('sessionStatus').textContent = status;
        }

        function recognizeAction() {
            if (!currentSource) {
                showError('Please open canvas or upload an image first.');
                return;
            }
            
            hideError();
            showLoading();
            
            // If an upload session exists, use it
            if (currentSource === 'upload' && currentSession) {
                callRecognize();
                return;
            }
            
            // Otherwise capture canvas
            if (currentSource === 'canvas') {
                canvas.toBlob(blob => {
                    const formData = new FormData();
                    formData.append('image', blob, 'drawing.png');
                    fetch('/upload_single', { method:'POST', body: formData })
                        .then(r => r.json())
                        .then(data => {
                            if (!data.success) throw new Error(data.error || 'Upload failed');
                            currentSession = data.session_id;
                            currentSource = 'canvas'; // Ensure source is set
                            updateSessionStatus();
                            return callRecognize();
                        })
                        .catch(err => {
                            hideLoading();
                            showError(err.message);
                        });
                }, 'image/png');
            } else {
                hideLoading();
                showError('No input available. Please open canvas or upload an image.');
            }
        }

        // uploads
        document.getElementById('singleInput').addEventListener('change', e => {
            if (!e.target.files.length) return;
            hideError(); showLoading();
            const fd = new FormData(); 
            fd.append('image', e.target.files[0]);
            fetch('/upload_single', { method:'POST', body: fd })
                .then(r=>r.json())
                .then(data=>{
                    if (!data.success) throw new Error(data.error || 'Upload failed');
                    currentSource = 'upload';
                    currentSession = data.session_id;
                    totalImages = 1;
                    currentImageIndex = 0;
                    showUploadedImage(data.image, 1, 0);
                    hideLoading();
                    updateModeToggleState(); // Re-enable all modes for upload
                    updateSessionStatus();
                }).catch(err=>{ hideLoading(); showError(err.message); });
        });
        document.getElementById('multipleInput').addEventListener('change', e => {
            if (!e.target.files || e.target.files.length === 0) return;
            
            const files = Array.from(e.target.files);
            hideError(); 
            showLoading();
            
            const fd = new FormData();
            // Append all files with the key 'images' (backend expects 'images')
            let validFiles = 0;
            files.forEach(f => {
                if (f.type.startsWith('image/')) {
                    fd.append('images', f);
                    validFiles++;
                }
            });
            
            if (validFiles === 0) {
                hideLoading();
                showError('Please select valid image files (PNG, JPG, JPEG, etc.).');
                e.target.value = ''; // Reset input
                return;
            }
            
            if (validFiles > 40) {
                hideLoading();
                showError('Maximum 40 images allowed. Please select fewer images.');
                e.target.value = ''; // Reset input
                return;
            }
            
            fetch('/upload_multiple', { method:'POST', body: fd })
                .then(r => r.json())
                .then(data => {
                    if (!data.success) throw new Error(data.error || 'Upload failed');
                    currentSource = 'upload';
                    currentSession = data.session_id;
                    totalImages = data.total_images || validFiles;
                    currentImageIndex = data.current_index || 0;
                    showUploadedImage(data.image, totalImages, currentImageIndex);
                    hideLoading();
                    updateModeToggleState(); // Re-enable all modes for upload
                    updateSessionStatus();
                    // Reset file input to allow uploading same files again
                    e.target.value = '';
                })
                .catch(err => { 
                    hideLoading(); 
                    showError(err.message);
                    e.target.value = ''; // Reset input on error
                });
        });

        function showUploadedImage(b64, total = 1, current = 0) {
            // Hide canvas if shown
            document.getElementById('canvasWrap').classList.remove('active');
            document.getElementById('canvasControls').style.display = 'none';
            // Show image display
            const imgEl = document.getElementById('uploadedImage');
            imgEl.src = `data:image/png;base64,${b64}`;
            document.getElementById('imageDisplay').classList.add('active');
            document.getElementById('actionControls').style.display = 'flex';
            
            // Show/hide navigation based on number of images
            const navEl = document.getElementById('imageNavigation');
            if (total > 1) {
                navEl.style.display = 'flex';
                updateImageCounter(current, total);
                updateNavigationButtons(current, total);
            } else {
                navEl.style.display = 'none';
            }
        }
        
        function updateImageCounter(current, total) {
            document.getElementById('imageCounter').textContent = `${current + 1} / ${total}`;
        }
        
        function updateNavigationButtons(current, total) {
            const prevBtn = document.getElementById('prevBtn');
            const nextBtn = document.getElementById('nextBtn');
            
            // Enable/disable buttons based on position
            prevBtn.disabled = (total <= 1);
            nextBtn.disabled = (total <= 1);
            
            // Visual feedback for navigation availability
            if (total > 1) {
                prevBtn.style.opacity = '1';
                nextBtn.style.opacity = '1';
            }
        }
        
        function navigateImage(direction) {
            if (!currentSession || totalImages <= 1) {
                showError('Multiple images required for navigation.');
                return;
            }
            
            hideError();
            showLoading();
            
            fetch('/navigate', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ 
                    session_id: currentSession, 
                    direction: direction 
                })
            })
            .then(r => r.json())
            .then(data => {
                if (!data.success) throw new Error(data.error || 'Navigation failed');
                currentImageIndex = data.current_index;
                totalImages = data.total_images;
                showUploadedImage(data.image, totalImages, currentImageIndex);
                hideLoading();
                // Clear previous recognition result when navigating
                updatePredictedText('‚Äî');
                recognizedText = '';
            })
            .catch(err => {
                hideLoading();
                showError(err.message);
            });
        }

        function callRecognize() {
            return fetch('/recognize', {
                method:'POST',
                headers:{'Content-Type':'application/json'},
                body: JSON.stringify({ session_id: currentSession, mode: currentMode })
            })
            .then(r=>r.json())
            .then(data=>{
                hideLoading();
                if (!data.success) throw new Error(data.error || 'Recognition failed');
                updatePredictedText(data.predicted_text);
                // Update confidence UI metadata if available
                currentConfidence = (typeof data.confidence === 'number') ? data.confidence : null;
                currentUncertaintyMessage = (data.is_uncertain && data.uncertainty_message) ? data.uncertainty_message : '';
                updateSessionStatus();
            })
            .catch(err=>{
                hideLoading();
                showError(err.message);
            });
        }

        function recognizeUploads() {
            if (!currentSession) { showError('Upload an image or draw first.'); return; }
            hideError(); showLoading();
            callRecognize();
        }

        function speakText() {
            if (!recognizedText) return;
            const btn = document.getElementById('ttsBtn');
            btn.disabled = true;
            btn.textContent = 'üîä Generating‚Ä¶';
            fetch('/tts', {
                method:'POST',
                headers:{'Content-Type':'application/json'},
                body: JSON.stringify({ text: recognizedText, lang:'kn' })
            }).then(r=>{
                if (!r.ok) throw new Error('TTS failed');
                return r.blob();
            }).then(blob=>{
                const url = URL.createObjectURL(blob);
                const audio = new Audio(url);
                audio.onended = ()=>{ URL.revokeObjectURL(url); btn.disabled=false; btn.textContent='üîä Hear Output'; };
                audio.onerror = ()=>{ URL.revokeObjectURL(url); btn.disabled=false; btn.textContent='üîä Hear Output'; showError('Could not play audio'); };
                audio.play();
            }).catch(err=>{
                btn.disabled=false; btn.textContent='üîä Hear Output'; showError(err.message);
            });
        }

        function downloadText() {
            if (!recognizedText) return;
            fetch('/download_text', {
                method:'POST',
                headers:{'Content-Type':'application/json'},
                body: JSON.stringify({ text: recognizedText })
            }).then(r=>r.blob()).then(blob=>{
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url; a.download = 'recognized_text.txt';
                document.body.appendChild(a); a.click();
                URL.revokeObjectURL(url); document.body.removeChild(a);
            }).catch(err=> showError(err.message));
        }

        function downloadPDF() {
            if (!recognizedText) return;
            fetch('/download_pdf', {
                method:'POST',
                headers:{'Content-Type':'application/json'},
                body: JSON.stringify({ text: recognizedText })
            }).then(r=>r.blob()).then(blob=>{
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url; a.download = 'recognized_text.pdf';
                document.body.appendChild(a); a.click();
                URL.revokeObjectURL(url); document.body.removeChild(a);
            }).catch(err=> showError(err.message));
        }

        function toggleDarkMode() {
            isDark = !isDark;
            document.body.classList.toggle('dark-mode', isDark);
            resetCanvas();
        }

        // Keyboard shortcuts for tools
        document.addEventListener('keydown', (e) => {
            // Ctrl/Cmd + Enter for recognition
            if (e.key === 'Enter' && (e.metaKey || e.ctrlKey)) {
                e.preventDefault();
                recognizeAction();
            }
            // 'P' key for pen tool (when canvas is active)
            if (e.key === 'p' || e.key === 'P') {
                if (document.getElementById('canvasWrap').classList.contains('active')) {
                    e.preventDefault();
                    setTool('pen');
                }
            }
            // 'E' key for eraser tool (when canvas is active)
            if (e.key === 'e' || e.key === 'E') {
                if (document.getElementById('canvasWrap').classList.contains('active')) {
                    e.preventDefault();
                    setTool('eraser');
                }
            }
        });
        
        // Initialize
        setupCanvas();
        setTool('pen'); // Initialize with pen tool
        updateModeToggleState(); // Initialize mode toggle state (all enabled initially)
        updateSessionStatus();
    </script>
</body>
</html>